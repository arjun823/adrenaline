use crate::ast_types::*;
use std::collections::HashMap;
use std::fmt::Write;

pub struct RustCodegen {
    output: String,
    indent: usize,
    var_types: HashMap<String, Type>,
}

impl RustCodegen {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
            var_types: HashMap::new(),
        }
    }

    pub fn generate(&mut self, program: &Program) -> String {
        self.output.clear();
        writeln!(self.output, "// Generated by Adrenaline Python â†’ Rust").ok();

        // Generate all functions
        for stmt in &program.statements {
            if let Statement::FunctionDef(func) = stmt {
                self.generate_function(func);
            }
        }

        // Generate main()
        self.generate_main(program);

        self.output.clone()
    }

    fn generate_function(&mut self, func: &FunctionDef) {
        let ret_type = self.type_to_rust(&func.return_type);
        write!(self.output, "fn {}(", func.name).ok();

        for (i, param) in func.params.iter().enumerate() {
            if i > 0 { write!(self.output, ", ").ok(); }
            write!(self.output, "{}: {}", param.name, self.type_to_rust(&param.typ)).ok();
            self.var_types.insert(param.name.clone(), param.typ.clone());
        }

        writeln!(self.output, ") -> {} {{", ret_type).ok();
        self.indent += 1;

        for stmt in &func.body {
            self.generate_statement(stmt);
        }

        // Default return for non-void
        match func.return_type {
            Type::Int => self.writeln("0"),
            Type::Float => self.writeln("0.0"),
            Type::Bool => self.writeln("false"),
            Type::String => self.writeln("String::new()"),
            Type::List(_) => self.writeln("vec![]"),
            _ => {}
        }

        self.indent -= 1;
        writeln!(self.output, "}}\n").ok();
        self.var_types.clear();
    }

    fn generate_main(&mut self, program: &Program) {
        writeln!(self.output, "fn main() {{").ok();
        self.indent += 1;

        if let Some(func) = program.statements.iter().find_map(|s| {
            if let Statement::FunctionDef(f) = s { Some(f) } else { None }
        }) {
            let mut args = Vec::new();
            for param in &func.params {
                args.push(match param.typ {
                    Type::Int => "0".to_string(),
                    Type::Float => "0.0".to_string(),
                    Type::Bool => "false".to_string(),
                    Type::String => "\"\".to_string()".to_string(),
                    Type::List(_) => "vec![]".to_string(),
                    _ => "0".to_string(),
                });
            }

            if func.return_type != Type::NoneType {
                writeln!(self.output, "{}let __result = {}({});", self.get_indent(), func.name, args.join(", ")).ok();
                writeln!(self.output, "{}println!(\"{{:?}}\", __result);", self.get_indent()).ok();
            } else {
                writeln!(self.output, "{}{}({});", self.get_indent(), func.name, args.join(", ")).ok();
            }
        }

        self.indent -= 1;
        writeln!(self.output, "}}").ok();
    }

    fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Assign(assign) => {
                let expr = self.expression_to_rust(&assign.value);
                if let Some(target) = assign.targets.first() {
                    self.writeln(&format!("let mut {} = {};", target, expr));
                    self.var_types.insert(target.clone(), assign.value.get_type());
                }
            }
            Statement::Return(expr_opt) => {
                if let Some(expr) = expr_opt {
                    self.writeln(&format!("return {};", self.expression_to_rust(expr)));
                } else {
                    self.writeln("return;");
                }
            }
            Statement::ExprStatement(expr) => {
                self.writeln(&self.expression_to_rust(expr));
            }
            Statement::If(if_stmt) => {
                let cond = self.expression_to_rust(&if_stmt.condition);
                self.writeln(&format!("if {} {{", cond));
                self.indent += 1;
                for s in &if_stmt.then_body { self.generate_statement(s); }
                self.indent -= 1;

                if let Some(else_body) = &if_stmt.else_body {
                    self.writeln("} else {");
                    self.indent += 1;
                    for s in else_body { self.generate_statement(s); }
                    self.indent -= 1;
                }
                self.writeln("}");
            }
            Statement::For(for_loop) => self.generate_for_loop(for_loop),
            _ => {}
        }
    }

    fn generate_for_loop(&mut self, for_loop: &ForLoop) {
        let iter = match &for_loop.iter {
            Expression::Call(func, args) if func.as_ident() == Some("range") => {
                let start = if args.len() == 1 { "0".to_string() } else { self.expression_to_rust(&args[0]) };
                let end = self.expression_to_rust(&args[args.len() - 1]);
                self.writeln(&format!("for {} in {}..{} {{", for_loop.target, start, end));
                self.indent += 1;
                self.var_types.insert(for_loop.target.clone(), Type::Int);
                for stmt in &for_loop.body { self.generate_statement(stmt); }
                self.indent -= 1;
                self.writeln("}");
                return;
            }
            _ => self.expression_to_rust(&for_loop.iter)
        };

        self.writeln(&format!("for {} in {} {{", for_loop.target, iter));
        self.indent += 1;
        for stmt in &for_loop.body { self.generate_statement(stmt); }
        self.indent -= 1;
        self.writeln("}");
    }

    fn expression_to_rust(&self, expr: &Expression) -> String {
        match expr {
            Expression::IntLit(n) => n.to_string(),
            Expression::FloatLit(f) => f.to_string(),
            Expression::BoolLit(b) => b.to_string(),
            Expression::StringLit(s) => format!("\"{}\"", s),
            Expression::Identifier(name) => name.clone(),
            Expression::BinOp(left, op, right) => {
                let l = self.expression_to_rust(left);
                let r = self.expression_to_rust(right);
                let op_str = match op {
                    BinOp::Add => "+", BinOp::Sub => "-", BinOp::Mult => "*", BinOp::Div => "/",
                    BinOp::FloorDiv => "/", BinOp::Mod => "%", BinOp::Pow => "**",
                    BinOp::Eq => "==", BinOp::NotEq => "!=", BinOp::Lt => "<", BinOp::LtE => "<=",
                    BinOp::Gt => ">", BinOp::GtE => ">=", BinOp::BitAnd => "&", BinOp::BitOr => "|",
                    BinOp::BitXor => "^", BinOp::LShift => "<<", BinOp::RShift => ">>",
                    _ => "op",
                };
                if op_str == "**" { format!("({}).pow({} as u32)", l, r) } else { format!("({} {} {})", l, op_str, r) }
            }
            Expression::Call(func, args) => {
                if let Some(fname) = func.as_ident() {
                    let args_str = args.iter().map(|a| self.expression_to_rust(a)).collect::<Vec<_>>().join(", ");
                    format!("{}({})", fname, args_str)
                } else { "0".to_string() }
            }
            Expression::Index(arr, idx) => format!("{}[{} as usize]", self.expression_to_rust(arr), self.expression_to_rust(idx)),
            Expression::List(items) => format!("vec![{}]", items.iter().map(|i| self.expression_to_rust(i)).collect::<Vec<_>>().join(", ")),
            _ => "0".to_string()
        }
    }

    fn type_to_rust(&self, typ: &Type) -> &'static str {
        match typ {
            Type::Int => "i64",
            Type::Float => "f64",
            Type::Bool => "bool",
            Type::String => "String",
            Type::List(_) => "Vec<i64>",
            Type::NoneType => "()",
            _ => "()",
        }
    }

    fn writeln(&mut self, line: &str) {
        writeln!(self.output, "{}{}", self.get_indent(), line).ok();
    }

    fn get_indent(&self) -> String {
        "    ".repeat(self.indent)
    }
}

trait ExprHelper {
    fn as_ident(&self) -> Option<&str>;
    fn get_type(&self) -> Type;
}

impl ExprHelper for Expression {
    fn as_ident(&self) -> Option<&str> {
        if let Expression::Identifier(name) = self { Some(name) } else { None }
    }
    fn get_type(&self) -> Type {
        match self {
            Expression::IntLit(_) => Type::Int,
            Expression::FloatLit(_) => Type::Float,
            Expression::BoolLit(_) => Type::Bool,
            Expression::StringLit(_) => Type::String,
            Expression::List(_) => Type::List(Box::new(Type::Int)),
            _ => Type::NoneType,
        }
    }
}

impl Default for RustCodegen { fn default() -> Self { Self::new() } }
